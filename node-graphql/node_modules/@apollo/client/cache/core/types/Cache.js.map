{"version":3,"file":"Cache.js","sourceRoot":"","sources":["../../../../src/cache/core/types/Cache.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  DataValue,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport type { Unmasked } from \"@apollo/client/masking\";\nimport type { ExtensionsWithStreamInfo } from \"@apollo/client/utilities/internal\";\n\nimport type { ApolloCache } from \"../cache.js\";\n\nimport type {\n  AllFieldsModifier,\n  MissingFieldError,\n  Modifiers,\n} from \"./common.js\";\nexport declare namespace Cache {\n  export type WatchCallback<TData = unknown> = (\n    diff: Cache.DiffResult<TData>,\n    lastDiff?: Cache.DiffResult<TData>\n  ) => void;\n\n  export interface ReadOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /**\n     * The GraphQL query shape to be used constructed using the `gql` template\n     * string tag from `graphql-tag`. The query will be used to determine the\n     * shape of the data to be read.\n     */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /**\n     * Any variables that the GraphQL query may depend on.\n     */\n    variables?: TVariables;\n\n    /**\n     * The root id to be used. Defaults to \"ROOT_QUERY\", which is the ID of the\n     * root query object. This property makes writeQuery capable of writing data\n     * to any object in the cache.\n     */\n    id?: string;\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n    returnPartialData?: boolean;\n  }\n\n  export interface WriteOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /**\n     * The GraphQL query shape to be used constructed using the `gql` template\n     * string tag from `graphql-tag`. The query will be used to determine the\n     * shape of the data to be read.\n     */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /**\n     * Any variables that the GraphQL query may depend on.\n     */\n    variables?: TVariables;\n\n    dataId?: string;\n    result: Unmasked<TData>;\n\n    /**\n     * Whether to notify query watchers.\n     * @defaultValue true\n     */\n    broadcast?: boolean;\n    /**\n     * When true, ignore existing field data rather than merging it with\n     * incoming data.\n     * @defaultValue false\n     */\n    overwrite?: boolean;\n\n    /**\n     * GraphQL extensions for the write operation. Any provided `extensions`\n     * are available in `merge` functions.\n     */\n    extensions?: ExtensionsWithStreamInfo;\n  }\n\n  export interface DiffOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > extends Omit<ReadOptions<TData, TVariables>, \"rootId\"> {\n    // The DiffOptions interface is currently just an alias for\n    // ReadOptions, though DiffOptions used to be responsible for\n    // declaring the returnPartialData option.\n  }\n\n  export interface WatchOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > extends DiffOptions<TData, TVariables> {\n    watcher?: object;\n    immediate?: boolean;\n    callback: WatchCallback<TData>;\n    lastDiff?: DiffResult<TData>;\n  }\n\n  export interface EvictOptions {\n    id?: string;\n    fieldName?: string;\n    args?: Record<string, any>;\n    broadcast?: boolean;\n  }\n\n  // Although you can call cache.reset() without options, its behavior can be\n  // configured by passing a Cache.ResetOptions object.\n  export interface ResetOptions {\n    discardWatches?: boolean;\n  }\n\n  export interface ModifyOptions<\n    Entity extends Record<string, any> = Record<string, any>,\n  > {\n    id?: string;\n    fields: Modifiers<Entity> | AllFieldsModifier<Entity>;\n    optimistic?: boolean;\n    broadcast?: boolean;\n  }\n\n  export interface BatchOptions<\n    TCache extends ApolloCache,\n    TUpdateResult = void,\n  > {\n    /**\n     * A function that performs cache operations. Receives the cache instance as its argument.\n     *\n     * The return value of this function becomes the return value of `batch`.\n     */\n    update(cache: TCache): TUpdateResult;\n\n    /**\n     * Controls how optimistic data is handled:\n     *\n     * - `string`: Creates a new optimistic layer with this ID. Use `removeOptimistic` later to remove it.\n     * - `true`: Updates the current top layer of the cache (including any optimistic data).\n     * - `false`: Updates only the root (non-optimistic) cache data.\n     *\n     * @defaultValue false\n     */\n    optimistic?: string | boolean;\n\n    /**\n     * If provided, removes the optimistic layer with this ID after the batch completes.\n     *\n     * This is useful for atomically applying server data while removing a pending optimistic update, triggering at most one broadcast for both operations.\n     *\n     * Note: this option is needed because calling `cache.removeOptimistic` during the transaction function may not be safe, since any modifications to cache layers may be discarded after the transaction finishes.\n     */\n    removeOptimistic?: string;\n\n    /**\n     * Optional callback invoked for each watcher affected by the batch operation.\n     *\n     * Receives the watch options, the new diff result, and optionally the previous diff result.\n     *\n     * Return `false` to prevent broadcasting to that specific watcher.\n     */\n    onWatchUpdated?: (\n      this: TCache,\n      watch: Cache.WatchOptions,\n      diff: Cache.DiffResult<any>,\n      lastDiff?: Cache.DiffResult<any> | undefined\n    ) => any;\n  }\n\n  export interface ReadQueryOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > {\n    /**\n     * The GraphQL query shape to be used constructed using the `gql` template\n     * string tag. The query will be used to determine the\n     * shape of the data to be read.\n     */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /**\n     * Any variables that the GraphQL query may depend on.\n     */\n    variables?: TVariables;\n\n    /**\n     * The root id to be used. Defaults to \"ROOT_QUERY\", which is the ID of the\n     * root query object. This property makes readQuery capable of reading data\n     * from any object in the cache.\n     */\n    id?: string;\n    /**\n     * Whether to return incomplete data rather than null.\n     * @defaultValue false\n     */\n    returnPartialData?: boolean;\n    /**\n     * Whether to read from optimistic or non-optimistic cache data. If\n     * this named option is provided, the optimistic parameter of the\n     * readQuery method can be omitted.\n     * @defaultValue false\n     */\n    optimistic?: boolean;\n  }\n\n  export type ReadFragmentOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = {\n    /**\n     * A GraphQL document created using the `gql` template string tag from\n     * `graphql-tag` with one or more fragments which will be used to determine\n     * the shape of data to read. If you provide more than one fragment in this\n     * document then you must also specify `fragmentName` to specify which\n     * fragment is the root fragment.\n     */\n    fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /**\n     * The name of the fragment in your GraphQL document to be used. If you do\n     * not provide a `fragmentName` and there is only one fragment in your\n     * `fragment` document then that fragment will be used.\n     */\n    fragmentName?: string;\n\n    /**\n     * Any variables that your GraphQL fragments depend on.\n     */\n    variables?: TVariables;\n\n    /**\n     * Whether to return incomplete data rather than null.\n     * @defaultValue false\n     */\n    returnPartialData?: boolean;\n    /**\n     * Whether to read from optimistic or non-optimistic cache data. If\n     * this named option is provided, the optimistic parameter of the\n     * readFragment method can be omitted.\n     * @defaultValue false\n     */\n    optimistic?: boolean;\n  } & Cache.CacheIdentifierOption<TData>;\n\n  export interface WriteQueryOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > {\n    /**\n     * The GraphQL query shape to be used constructed using the `gql` template\n     * string tag from `graphql-tag`. The query will be used to determine the\n     * shape of the data to be read.\n     */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /**\n     * Any variables that the GraphQL query may depend on.\n     */\n    variables?: TVariables;\n\n    /**\n     * The root id to be used. Defaults to \"ROOT_QUERY\", which is the ID of the\n     * root query object. This property makes writeQuery capable of writing data\n     * to any object in the cache.\n     */\n    id?: string;\n\n    /**\n     * The data to write to the store.\n     */\n    data: Unmasked<TData>;\n    /**\n     * Whether to notify query watchers.\n     * @defaultValue true\n     */\n    broadcast?: boolean;\n    /**\n     * When true, ignore existing field data rather than merging it with\n     * incoming data.\n     * @defaultValue false\n     */\n    overwrite?: boolean;\n\n    /**\n     * GraphQL extensions for the write operation. Any provided `extensions`\n     * are available in `merge` functions.\n     */\n    extensions?: ExtensionsWithStreamInfo;\n  }\n\n  export type WriteFragmentOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = {\n    /**\n     * A GraphQL document created using the `gql` template string\n     * with one or more fragments which will be used to determine\n     * the shape of data to read. If you provide more than one fragment in this\n     * document then you must also specify `fragmentName` to specify specify which\n     * fragment is the root fragment.\n     */\n    fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /**\n     * The name of the fragment in your GraphQL document to be used. If you do\n     * not provide a `fragmentName` and there is only one fragment in your\n     * `fragment` document then that fragment will be used.\n     */\n    fragmentName?: string;\n\n    /**\n     * Any variables that your GraphQL fragments depend on.\n     */\n    variables?: TVariables;\n    /**\n     * The data to write to the store.\n     */\n    data: Unmasked<TData>;\n    /**\n     * Whether to notify query watchers.\n     * @defaultValue true\n     */\n    broadcast?: boolean;\n    /**\n     * When true, ignore existing field data rather than merging it with\n     * incoming data.\n     * @defaultValue false\n     */\n    overwrite?: boolean;\n  } & Cache.CacheIdentifierOption<TData>;\n\n  export interface UpdateQueryOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > extends Omit<\n      ReadQueryOptions<TData, TVariables> &\n        WriteQueryOptions<TData, TVariables>,\n      \"data\"\n    > {}\n\n  export type UpdateFragmentOptions<\n    TData,\n    TVariables extends OperationVariables,\n  > = Omit<\n    ReadFragmentOptions<TData, TVariables> &\n      WriteFragmentOptions<TData, TVariables>,\n    \"data\" | \"id\" | \"from\"\n  > &\n    Cache.CacheIdentifierOption<TData>;\n\n  export type DiffResult<TData> =\n    | {\n        result: DataValue.Complete<TData>;\n        complete: true;\n        missing?: never;\n        fromOptimisticTransaction?: boolean;\n      }\n    | {\n        result: DataValue.Partial<TData> | null;\n        complete: false;\n        missing?: MissingFieldError;\n        fromOptimisticTransaction?: boolean;\n      };\n\n  export type CacheIdentifierOption<TData> =\n    | {\n        /**\n         * The root id to be used. This id should take the same form as the\n         * value returned by the `cache.identify` function. If a value with your\n         * id does not exist in the store, `null` will be returned.\n         */\n        id?: string;\n\n        /**\n         * An object containing a `__typename` and primary key fields\n         * (such as `id`) identifying the entity object from which the fragment will\n         * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n         * (uncommon).\n         *\n         * @remarks\n         * `from` is given precedence over `id` when both are provided.\n         */\n        from?: never;\n      }\n    | {\n        /**\n         * The root id to be used. This id should take the same form as the\n         * value returned by the `cache.identify` function. If a value with your\n         * id does not exist in the store, `null` will be returned.\n         */\n        id?: never;\n\n        /**\n         * An object containing a `__typename` and primary key fields\n         * (such as `id`) identifying the entity object from which the fragment will\n         * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n         * (uncommon).\n         *\n         * @remarks\n         * `from` is given precedence over `id` when both are provided.\n         */\n        from?: ApolloCache.FromOptionValue<TData>;\n      };\n}\n"]}