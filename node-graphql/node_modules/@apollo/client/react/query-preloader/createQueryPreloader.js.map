{"version":3,"file":"createQueryPreloader.js","sourceRoot":"","sources":["../../../src/react/query-preloader/createQueryPreloader.ts"],"names":[],"mappings":"AAWA,OAAO,EACL,qBAAqB,EACrB,iBAAiB,EACjB,sBAAsB,EACtB,YAAY,GACb,MAAM,+BAA+B,CAAC;AAKvC,OAAO,EAAE,oBAAoB,EAAE,MAAM,6CAA6C,CAAC;AAEnF,OAAO,EAAE,QAAQ,EAAE,MAAM,4BAA4B,CAAC;AAgItD;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,UAAU,oBAAoB,CAClC,MAAoB;IAEpB,OAAO,QAAQ,CACb,sBAAsB,EACtB,qBAAqB,EACrB,MAAM,CACP,CAAC,MAAM,CAAC,CAAC;AACZ,CAAC;AAED,MAAM,qBAAqB,GAAgC,CAAC,MAAM,EAAE,EAAE;IACpE,SAAS,YAAY,CAInB,KAA0D,EAC1D,UACgC,EAAS;QAEzC,MAAM,QAAQ,GAAG,IAAI,sBAAsB,CACzC,MAAM,CAAC,UAAU,CAAC;YAChB,GAAG,OAAO;YACV,KAAK;YACL,2BAA2B,EAAE,KAAK;SACS,CAAC,EAC9C;YACE,oBAAoB,EAClB,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,QAAQ,EAAE,oBAAoB;SAC9D,CACF,CAAC;QAEF,MAAM,OAAO,GAAG,YAAY,CAAC,QAAQ,CAGpC,CAAC;QACF,yBAAyB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC7C,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,OAAO,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE;QACjC,SAAS,CACP,QAAmB;YAEnB,qBAAqB,CAAC,QAAQ,CAAC,CAAC;YAChC,OAAO,iBAAiB,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,CAAC;QAC1D,CAAC;KACF,CAAC,CAAC;AACL,CAAC,CAAC;AAEF;;;;;;;GAOG;AACH,sFAAsF;AACtF,SAAS,yBAAyB,CAChC,OAAyC,EACzC,QAAgC;IAEhC,MAAM,EAAE,WAAW,EAAE,kBAAkB,EAAE,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC;IACjE,QAAQ,CAAC,QAAQ,CAAC,OAAO,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;IACzD,uEAAuE;IACvE,qCAAqC;IACrC,6EAA6E;IAC7E,wFAAwF;IACxF,QAAQ,CAAC,MAAM,GAAG,kBAAkB,CAAC,QAAQ,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AACrE,CAAC;AAOD,sFAAsF;AACtF,SAAS,kBAAkB,CACzB,cAA8B,EAC9B,WAAuB;IAEvB,OAAO,UAAU,GAAG,IAAI;QACtB,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC1B,MAAM,OAAO,GAAG,cAAc,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACjD,WAAW,EAAE,CAAC;QACd,OAAO,OAAO,CAAC;IACjB,CAAC,CAAC;AACJ,CAAC;AAED,sFAAsF;AACtF,SAAS,UAAU,CAAC,QAAgC;IAClD,MAAM,WAAW,GAAG,QAAQ,CAAC,UAAU,EAAE,CAAC;IAC1C,MAAM,cAAc,GAAG,QAAQ,CAAC,OAAO,CAAC;IAExC,OAAO;QACL,WAAW;QACX,kBAAkB,EAAE,GAAG,EAAE,CACvB,cAAc,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC;KACtD,CAAC;AACJ,CAAC;AAED,MAAM,QAAQ,GAAG,IAAI,oBAAoB,CAAa,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC","sourcesContent":["import type {\n  ApolloClient,\n  DefaultContext,\n  DocumentNode,\n  ErrorPolicy,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { PreloadedQueryRef } from \"@apollo/client/react\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  InternalQueryReference,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\nimport type {\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport { FinalizationRegistry } from \"@apollo/client/utilities/internal/ponyfills\";\n\nimport { wrapHook } from \"../hooks/internal/index.js\";\n\nexport type PreloadQueryFetchPolicy = Extract<\n  WatchQueryFetchPolicy,\n  \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n>;\n\nexport type PreloadQueryOptions<\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n  context?: DefaultContext;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n  errorPolicy?: ErrorPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n  fetchPolicy?: PreloadQueryFetchPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n  returnPartialData?: boolean;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n  refetchWritePolicy?: RefetchWritePolicy;\n} & VariablesOption<TVariables>;\n\n/**\n * A function that will begin loading a query when called. It's result can be\n * read by `useReadQuery` which will suspend until the query is loaded.\n * This is useful when you want to start loading a query as early as possible\n * outside of a React component.\n *\n * @example\n *\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * const queryRef = preloadQuery(query, { variables, ...otherOptions });\n *\n * function App() {\n *   return (\n *     <Suspense fallback={<div>Loading</div>}>\n *       <MyQuery />\n *     </Suspense>\n *   );\n * }\n *\n * function MyQuery() {\n *   const { data } = useReadQuery(queryRef);\n *\n *   // do something with `data`\n * }\n * ```\n */\nexport interface PreloadQueryFunction {\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): PreloadedQueryRef<\n    TData,\n    TVariables,\n    \"complete\" | \"streaming\" | \"partial\" | \"empty\"\n  >;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"empty\">;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n    }\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\">;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    ...[options]: {} extends TVariables ?\n      [options?: PreloadQueryOptions<NoInfer<TVariables>>]\n    : [options: PreloadQueryOptions<NoInfer<TVariables>>]\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\">;\n\n  /**\n   * A function that returns a promise that resolves when the query has finished\n   * loading. The promise resolves with the `QueryReference` itself.\n   *\n   * @remarks\n   * This method is useful for preloading queries in data loading routers, such\n   * as [React Router](https://reactrouter.com/en/main) or [TanStack Router](https://tanstack.com/router),\n   * to prevent routes from transitioning until the query has finished loading.\n   * `data` is not exposed on the promise to discourage using the data in\n   * `loader` functions and exposing it to your route components. Instead, we\n   * prefer you rely on `useReadQuery` to access the data to ensure your\n   * component can rerender with cache updates. If you need to access raw query\n   * data, use `client.query()` directly.\n   *\n   * @example\n   * Here's an example using React Router's `loader` function:\n   *\n   * ```ts\n   * import { createQueryPreloader } from \"@apollo/client\";\n   *\n   * const preloadQuery = createQueryPreloader(client);\n   *\n   * export async function loader() {\n   *   const queryRef = preloadQuery(GET_DOGS_QUERY);\n   *\n   *   return preloadQuery.toPromise(queryRef);\n   * }\n   *\n   * export function RouteComponent() {\n   *   const queryRef = useLoaderData();\n   *   const { data } = useReadQuery(queryRef);\n   *\n   *   // ...\n   * }\n   * ```\n   */\n  toPromise<TQueryRef extends PreloadedQueryRef<any, any, any>>(\n    queryRef: TQueryRef\n  ): Promise<TQueryRef>;\n}\n\n/**\n * A higher order function that returns a `preloadQuery` function which\n * can be used to begin loading a query with the given `client`. This is useful\n * when you want to start loading a query as early as possible outside of a\n * React component.\n *\n * > Refer to the [Suspense - Initiating queries outside React](https://www.apollographql.com/docs/react/data/suspense#initiating-queries-outside-react) section for a more in-depth overview.\n *\n * @param client - The `ApolloClient` instance that will be used to load queries\n * from the returned `preloadQuery` function.\n * @returns The `preloadQuery` function.\n *\n * @example\n *\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * ```\n */\nexport function createQueryPreloader(\n  client: ApolloClient\n): PreloadQueryFunction {\n  return wrapHook(\n    \"createQueryPreloader\",\n    _createQueryPreloader,\n    client\n  )(client);\n}\n\nconst _createQueryPreloader: typeof createQueryPreloader = (client) => {\n  function preloadQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> &\n      VariablesOption<TVariables> = {} as any\n  ): PreloadedQueryRef<TData, TVariables> {\n    const queryRef = new InternalQueryReference(\n      client.watchQuery({\n        ...options,\n        query,\n        notifyOnNetworkStatusChange: false,\n      } as ApolloClient.WatchQueryOptions<any, any>),\n      {\n        autoDisposeTimeoutMs:\n          client.defaultOptions.react?.suspense?.autoDisposeTimeoutMs,\n      }\n    );\n\n    const wrapped = wrapQueryRef(queryRef) as unknown as PreloadedQueryRef<\n      TData,\n      TVariables\n    >;\n    softRetainWhileReferenced(wrapped, queryRef);\n    return wrapped;\n  }\n\n  return Object.assign(preloadQuery, {\n    toPromise<TQueryRef extends PreloadedQueryRef<any, any, any>>(\n      queryRef: TQueryRef\n    ) {\n      assertWrappedQueryRef(queryRef);\n      return getWrappedPromise(queryRef).then(() => queryRef);\n    },\n  });\n};\n\n/**\n * Soft-retains the underlying `InternalQueryReference` while the `PreloadedQueryRef`\n * is still reachable.\n * When the `PreloadedQueryRef` is garbage collected, the soft retain is\n * disposed of, but only after the initial query has finished loading.\n * Once the `InternalQueryReference` is properly retained, the check for garbage\n * collection is unregistered and the soft retain is disposed of immediately.\n */\n// this is an individual function to avoid closing over any values more than necessary\nfunction softRetainWhileReferenced(\n  wrapped: PreloadedQueryRef<any, any, any>,\n  queryRef: InternalQueryReference\n) {\n  const { softDispose, delayedSoftDispose } = getCleanup(queryRef);\n  registry.register(wrapped, delayedSoftDispose, queryRef);\n  // This will unregister the cleanup from the finalization registry when\n  // the queryRef is properly retained.\n  // This is mostly done to keep the FinalizationRegistry from holding too many\n  // cleanup functions, as our React Native polyfill has to iterate all of them regularly.\n  queryRef.retain = unregisterOnRetain(queryRef.retain, softDispose);\n}\n\ntype RetainFunction = (\n  this: InternalQueryReference,\n  ...args: Parameters<InternalQueryReference[\"retain\"]>\n) => ReturnType<InternalQueryReference[\"retain\"]>;\n\n// this is an individual function to avoid closing over any values more than necessary\nfunction unregisterOnRetain(\n  originalRetain: RetainFunction,\n  softDispose: () => void\n): RetainFunction {\n  return function (...args) {\n    registry.unregister(this);\n    const dispose = originalRetain.apply(this, args);\n    softDispose();\n    return dispose;\n  };\n}\n\n// this is an individual function to avoid closing over any values more than necessary\nfunction getCleanup(queryRef: InternalQueryReference) {\n  const softDispose = queryRef.softRetain();\n  const initialPromise = queryRef.promise;\n\n  return {\n    softDispose,\n    delayedSoftDispose: () =>\n      initialPromise.finally(softDispose).catch(() => {}),\n  };\n}\n\nconst registry = new FinalizationRegistry<() => void>((cleanup) => cleanup());\n"]}