{"version":3,"file":"useSuspenseHookCacheKey.js","sourceRoot":"","sources":["../../../../src/react/hooks/internal/useSuspenseHookCacheKey.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAI/B,OAAO,EAAE,kBAAkB,EAAE,MAAM,0BAA0B,CAAC;AAG9D,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;AAS5C,MAAM,UAAU,uBAAuB,CACrC,KAAmB,EACnB,OAEmC;IAEnC,MAAM,EAAE,QAAQ,GAAG,EAAE,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;IAC7C,MAAM,kBAAkB,GAAG,kBAAkB,CAAC,SAAS,CAAC,CAAC;IAEzD,0EAA0E;IAC1E,oEAAoE;IACpE,0EAA0E;IAC1E,wEAAwE;IACxE,2EAA2E;IAC3E,2EAA2E;IAC3E,0EAA0E;IAC1E,IAAI,CAAC,iBAAiB,EAAE,oBAAoB,CAAC,GAC3C,KAAK,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC;IAErC,IAAI,OAAO,KAAK,SAAS,IAAI,iBAAiB,KAAK,kBAAkB,EAAE,CAAC;QACtE,oBAAoB,CAAC,CAAC,iBAAiB,GAAG,kBAAkB,CAAC,CAAC,CAAC;IACjE,CAAC;IAED,OAAO;QACL,KAAK;QACL,iBAAiB;QACjB,GAAI,EAAY,CAAC,MAAM,CAAC,QAAQ,CAAC;KACf,CAAC;AACvB,CAAC","sourcesContent":["import type { DocumentNode } from \"graphql\";\nimport * as React from \"react\";\n\nimport type { OperationVariables } from \"@apollo/client\";\nimport type { CacheKey } from \"@apollo/client/react/internal\";\nimport { canonicalStringify } from \"@apollo/client/utilities\";\n\nimport type { SkipToken } from \"../constants.js\";\nimport { skipToken } from \"../constants.js\";\n\nexport declare namespace useSuspenseHookCacheKey {\n  export interface Options {\n    variables?: OperationVariables;\n    queryKey?: string | number | any[];\n  }\n}\n\nexport function useSuspenseHookCacheKey(\n  query: DocumentNode,\n  options:\n    | (SkipToken & Partial<useSuspenseHookCacheKey.Options>)\n    | useSuspenseHookCacheKey.Options\n) {\n  const { queryKey = [], variables } = options;\n  const canonicalVariables = canonicalStringify(variables);\n\n  // This state value let's us maintain the variables used for the cache key\n  // when `skipToken` is used to skip a query after its been executed.\n  // Since options aren't provided when using `skipToken`, `variables` would\n  // otherwise disappear which means we'd return a new cache key without a\n  // variables value which creates a new `ObservableQuery` instance. This was\n  // particularly problematic when `refetchQueries` was used because it meant\n  // refetching against an `ObservableQuery` instance that had no variables.\n  let [cacheKeyVariables, setCacheKeyVariables] =\n    React.useState(canonicalVariables);\n\n  if (options !== skipToken && cacheKeyVariables !== canonicalVariables) {\n    setCacheKeyVariables((cacheKeyVariables = canonicalVariables));\n  }\n\n  return [\n    query,\n    cacheKeyVariables,\n    ...([] as any[]).concat(queryKey),\n  ] satisfies CacheKey;\n}\n"]}