{"version":3,"file":"FragmentReference.js","sourceRoot":"","sources":["../../../../src/react/internal/cache/FragmentReference.ts"],"names":[],"mappings":"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","sourcesContent":["import { equal } from \"@wry/equality\";\nimport type { Subscription } from \"rxjs\";\n\nimport type { ApolloClient, OperationVariables } from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { DecoratedPromise } from \"@apollo/client/utilities/internal\";\nimport {\n  createFulfilledPromise,\n  decoratePromise,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { FragmentKey } from \"./types.js\";\n\ntype FragmentRefPromise<TData> = DecoratedPromise<TData>;\ntype Listener<TData> = (promise: FragmentRefPromise<TData>) => void;\n\ninterface FragmentReferenceOptions {\n  autoDisposeTimeoutMs?: number;\n  onDispose?: () => void;\n}\n\nexport class FragmentReference<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  public readonly observable: ApolloClient.ObservableFragment<TData | null>;\n  public readonly key: FragmentKey = {};\n  public promise!: FragmentRefPromise<MaybeMasked<TData>>;\n\n  private resolve: ((result: MaybeMasked<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private subscription!: Subscription;\n  private listeners = new Set<Listener<MaybeMasked<TData>>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private references = 0;\n\n  constructor(\n    client: ApolloClient,\n    watchFragmentOptions: ApolloClient.WatchFragmentOptions<\n      TData,\n      TVariables\n    > & {\n      from: string | null | Array<string | null>;\n    },\n    options: FragmentReferenceOptions\n  ) {\n    this.dispose = this.dispose.bind(this);\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n\n    this.observable = client.watchFragment(watchFragmentOptions);\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    const result = this.observable.getCurrentResult();\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this fragmentRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    this.promise =\n      result.complete ?\n        createFulfilledPromise(result.data)\n      : this.createPendingPromise();\n    this.subscribeToFragment();\n\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  listen(listener: Listener<MaybeMasked<TData>>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private subscribeToFragment() {\n    this.subscription = this.observable.subscribe(\n      this.handleNext.bind(this),\n      this.handleError.bind(this)\n    );\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n\n  private handleNext(result: ApolloClient.WatchFragmentResult<TData | null>) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        if (result.complete) {\n          return this.resolve?.(result.data);\n        }\n\n        this.deliver(this.promise);\n        break;\n      }\n      case \"fulfilled\": {\n        // This can occur when we already have a result written to the cache and\n        // we subscribe for the first time. We create a fulfilled promise in the\n        // constructor with a value that is the same as the first emitted value\n        // so we want to skip delivering it.\n        if (equal(this.promise.value, result.data)) {\n          return;\n        }\n\n        this.promise =\n          result.complete ?\n            createFulfilledPromise(result.data)\n          : this.createPendingPromise();\n\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private handleError(error: unknown) {\n    this.reject?.(error);\n  }\n\n  private deliver(promise: FragmentRefPromise<MaybeMasked<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private createPendingPromise() {\n    return decoratePromise(\n      new Promise<MaybeMasked<TData>>((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      })\n    );\n  }\n}\n"]}