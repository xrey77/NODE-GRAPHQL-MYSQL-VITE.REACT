{"version":3,"file":"defer20220824.js","sourceRoot":"","sources":["../../../src/incremental/handlers/defer20220824.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  DocumentNode,\n  FormattedExecutionResult,\n  GraphQLFormattedError,\n} from \"graphql\";\n\nimport type { ApolloLink } from \"@apollo/client/link\";\nimport type { DeepPartial, HKT } from \"@apollo/client/utilities\";\nimport {\n  DeepMerger,\n  hasDirectives,\n  isNonEmptyArray,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { Incremental } from \"../types.js\";\n\nexport declare namespace Defer20220824Handler {\n  interface Defer20220824Result extends HKT {\n    arg1: unknown; // TData\n    arg2: unknown; // TExtensions\n    return: Defer20220824Handler.Chunk<Record<string, unknown>>;\n  }\n  export interface TypeOverrides {\n    AdditionalApolloLinkResultTypes: Defer20220824Result;\n  }\n\n  export type InitialResult<TData = Record<string, unknown>> = {\n    data?: TData | null | undefined;\n    errors?: ReadonlyArray<GraphQLFormattedError>;\n    extensions?: Record<string, unknown>;\n    hasNext: boolean;\n    incremental?: ReadonlyArray<IncrementalResult<TData>>;\n  };\n\n  export type SubsequentResult<TData = Record<string, unknown>> = {\n    extensions?: Record<string, unknown>;\n    hasNext: boolean;\n    incremental?: Array<IncrementalResult<TData>>;\n  };\n\n  export type IncrementalDeferResult<TData = Record<string, unknown>> = {\n    data?: TData | null;\n    errors?: ReadonlyArray<GraphQLFormattedError>;\n    extensions?: Record<string, unknown>;\n    path?: Incremental.Path;\n    label?: string;\n  };\n\n  export type IncrementalStreamResult<TData = Array<unknown>> = {\n    errors?: ReadonlyArray<GraphQLFormattedError>;\n    items?: TData;\n    path?: Incremental.Path;\n    label?: string;\n    extensions?: Record<string, unknown>;\n  };\n\n  export type IncrementalResult<TData = Record<string, unknown>> =\n    | IncrementalDeferResult<TData>\n    | IncrementalStreamResult<TData>;\n\n  export type Chunk<TData extends Record<string, unknown>> =\n    | InitialResult<TData>\n    | SubsequentResult<TData>;\n}\n\nclass DeferRequest<TData extends Record<string, unknown>>\n  implements\n    Incremental.IncrementalRequest<Defer20220824Handler.Chunk<TData>, TData>\n{\n  public hasNext = true;\n\n  private errors: Array<GraphQLFormattedError> = [];\n  private extensions: Record<string, any> = {};\n  private data: any = {};\n  // This tracks paths for `@stream` arrays that returns items: null due to\n  // errors thrown for non-null array items. We stop processing future updates\n  // to these stream arrays to prevent creating sparse arrays or inserting\n  // `null` for an expected non-null value which could cause runtime crashes.\n  private ignoredImpossibleStreamPaths = new Set<string>();\n\n  private merge(\n    normalized: FormattedExecutionResult<TData>,\n    atPath?: DeepMerger.MergeOptions[\"atPath\"]\n  ) {\n    if (normalized.data !== undefined) {\n      this.data = new DeepMerger({ arrayMerge: \"truncate\" }).merge(\n        this.data,\n        normalized.data,\n        { atPath }\n      );\n    }\n    if (normalized.errors) {\n      this.errors.push(...normalized.errors);\n    }\n    Object.assign(this.extensions, normalized.extensions);\n  }\n\n  handle(\n    // we'll get `undefined` here in case of a `no-cache` fetch policy,\n    // so we'll continue with the last value this request had accumulated\n    cacheData: TData | DeepPartial<TData> | null | undefined = this.data,\n    chunk: Defer20220824Handler.Chunk<TData>\n  ): FormattedExecutionResult<TData> {\n    this.hasNext = chunk.hasNext;\n    this.data = cacheData;\n\n    if (hasIncrementalChunks(chunk)) {\n      for (const incremental of chunk.incremental) {\n        const { path, errors, extensions } = incremental;\n\n        if (\"items\" in incremental) {\n          // Remove the array index from the end of the array since each future\n          // chunk sends a different array index. This normalizes the path to\n          // ensure we ignore updates to this field if `items` is `null`.\n          const stringPath = path?.slice(0, -1).join(\".\") ?? \"\";\n\n          if (incremental.items === null) {\n            this.ignoredImpossibleStreamPaths.add(stringPath);\n          }\n\n          if (this.ignoredImpossibleStreamPaths.has(stringPath)) {\n            this.merge({ errors, extensions });\n            continue;\n          }\n        }\n\n        let data: any =\n          \"items\" in incremental ? incremental.items\n            // Ensure `data: null` isn't merged for `@defer` responses by\n            // falling back to `undefined`\n          : \"data\" in incremental ? incremental.data ?? undefined\n          : undefined;\n\n        if (path && typeof path.at(-1) === \"number\" && Array.isArray(data)) {\n          const startingIdx = path.at(-1) as number;\n          data.forEach((item, idx) => {\n            this.merge({ data: item }, [\n              ...path!.slice(0, -1),\n              startingIdx + idx,\n            ]);\n          });\n        } else {\n          this.merge({ data }, path);\n        }\n\n        this.merge({ errors, extensions });\n      }\n    } else {\n      this.merge(chunk);\n    }\n\n    const result: FormattedExecutionResult<TData> = { data: this.data };\n\n    if (isNonEmptyArray(this.errors)) {\n      result.errors = this.errors;\n    }\n\n    if (Object.keys(this.extensions).length > 0) {\n      result.extensions = this.extensions;\n    }\n\n    return result;\n  }\n}\n\n/**\n * This handler implements the `@defer` directive as specified in this historical commit:\n * https://github.com/graphql/graphql-spec/tree/48cf7263a71a683fab03d45d309fd42d8d9a6659/spec\n */\nexport class Defer20220824Handler\n  implements Incremental.Handler<Defer20220824Handler.Chunk<any>>\n{\n  isIncrementalResult(\n    result: Record<string, any>\n  ): result is\n    | Defer20220824Handler.SubsequentResult\n    | Defer20220824Handler.InitialResult {\n    return \"hasNext\" in result;\n  }\n\n  extractErrors(result: ApolloLink.Result<any>) {\n    const acc: GraphQLFormattedError[] = [];\n    const push = ({\n      errors,\n    }: {\n      errors?: ReadonlyArray<GraphQLFormattedError>;\n    }) => {\n      if (errors) {\n        acc.push(...errors);\n      }\n    };\n    if (this.isIncrementalResult(result)) {\n      if (\"errors\" in result) {\n        push(result);\n      }\n      if (hasIncrementalChunks(result)) {\n        result.incremental.forEach(push);\n      }\n    }\n    if (acc.length) {\n      return acc;\n    }\n  }\n\n  prepareRequest(request: ApolloLink.Request): ApolloLink.Request {\n    if (hasDirectives([\"defer\", \"stream\"], request.query)) {\n      const context = request.context ?? {};\n      const http = (context.http ??= {});\n      http.accept = [\n        \"multipart/mixed;deferSpec=20220824\",\n        ...(http.accept || []),\n      ];\n    }\n\n    return request;\n  }\n  startRequest<TData extends Record<string, unknown>>(_: {\n    query: DocumentNode;\n  }) {\n    return new DeferRequest<TData>();\n  }\n}\n\n// only exported for use in tests\nexport function hasIncrementalChunks(\n  result: Record<string, any>\n): result is Required<Defer20220824Handler.SubsequentResult> {\n  return isNonEmptyArray(result.incremental);\n}\n"]}