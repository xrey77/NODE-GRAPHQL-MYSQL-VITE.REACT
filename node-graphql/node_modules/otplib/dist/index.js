import{generateSecret as V,ConfigurationError as b}from"@otplib/core";import{generate as R,generateSync as x,verify as G,verifySync as H}from"@otplib/hotp";import{generate as v,generateSync as C,verify as U,verifySync as B}from"@otplib/totp";import{generateTOTP as A,generateHOTP as D}from"@otplib/uri";import{createGuardrails as S}from"@otplib/core";import{base32 as g}from"@otplib/plugin-base32-scure";import{crypto as u}from"@otplib/plugin-crypto-noble";function c(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??u,base32:t.base32??g,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??S()}}function O(t){return{...c(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0}}function l(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new b("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new b(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function I(t){let{crypto:e=u,base32:r=g,length:a=20}=t||{};return V({crypto:e,base32:r,length:a})}function f(t){let{strategy:e="totp",issuer:r,label:a,secret:i,algorithm:o="sha1",digits:p=6,period:s=30,counter:n}=t;return l(e,n,{totp:()=>A({issuer:r,label:a,secret:i,algorithm:o,digits:p,period:s}),hotp:y=>D({issuer:r,label:a,secret:i,algorithm:o,digits:p,counter:y})})}async function m(t){let e=c(t),{secret:r,crypto:a,base32:i,algorithm:o,digits:p}=e,s={secret:r,crypto:a,base32:i,algorithm:o,digits:p};return l(e.strategy,e.counter,{totp:()=>v({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>R({...s,counter:n,guardrails:e.guardrails})})}function T(t){let e=c(t),{secret:r,crypto:a,base32:i,algorithm:o,digits:p}=e,s={secret:r,crypto:a,base32:i,algorithm:o,digits:p};return l(e.strategy,e.counter,{totp:()=>C({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>x({...s,counter:n,guardrails:e.guardrails})})}async function P(t){let e=O(t),{secret:r,token:a,crypto:i,base32:o,algorithm:p,digits:s}=e,n={secret:r,token:a,crypto:i,base32:o,algorithm:p,digits:s};return l(e.strategy,e.counter,{totp:()=>U({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:y=>G({...n,counter:y,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function h(t){let e=O(t),{secret:r,token:a,crypto:i,base32:o,algorithm:p,digits:s}=e,n={secret:r,token:a,crypto:i,base32:o,algorithm:p,digits:s};return l(e.strategy,e.counter,{totp:()=>B({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:y=>H({...n,counter:y,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}import{createGuardrails as w,generateSecret as k}from"@otplib/core";var d=class{strategy;crypto;base32;guardrails;constructor(e={}){let{strategy:r="totp",crypto:a=u,base32:i=g,guardrails:o}=e;this.strategy=r,this.crypto=a,this.base32=i,this.guardrails=w(o)}getStrategy(){return this.strategy}generateSecret(e=20){return k({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return m({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateSync(e){return T({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}async verify(e){return P({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}verifySync(e){return h({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateURI(e){return f({...e,strategy:this.strategy})}};import{HOTP as te}from"@otplib/hotp";import{TOTP as ae}from"@otplib/totp";import{createGuardrails as oe,stringToBytes as se,wrapResult as ne,wrapResultAsync as pe}from"@otplib/core";import{NobleCryptoPlugin as ge}from"@otplib/plugin-crypto-noble";import{ScureBase32Plugin as le}from"@otplib/plugin-base32-scure";export{te as HOTP,ge as NobleCryptoPlugin,d as OTP,le as ScureBase32Plugin,ae as TOTP,oe as createGuardrails,m as generate,I as generateSecret,T as generateSync,f as generateURI,se as stringToBytes,P as verify,h as verifySync,ne as wrapResult,pe as wrapResultAsync};
//# sourceMappingURL=index.js.map