import{createGuardrails as A,generateSecret as I}from"@otplib/core";import{createGuardrails as S}from"@otplib/core";import{base32 as y}from"@otplib/plugin-base32-scure";import{crypto as c}from"@otplib/plugin-crypto-noble";function l(r){return{secret:r.secret,strategy:r.strategy??"totp",crypto:r.crypto??c,base32:r.base32??y,algorithm:r.algorithm??"sha1",digits:r.digits??6,period:r.period??30,epoch:r.epoch??Math.floor(Date.now()/1e3),t0:r.t0??0,counter:r.counter,guardrails:r.guardrails??S()}}function f(r){return{...l(r),token:r.token,epochTolerance:r.epochTolerance??0,counterTolerance:r.counterTolerance??0}}import{generateSecret as E,ConfigurationError as m}from"@otplib/core";import{generate as V,generateSync as R,verify as G,verifySync as x}from"@otplib/hotp";import{generate as H,generateSync as v,verify as C,verifySync as D}from"@otplib/totp";import{generateTOTP as U,generateHOTP as B}from"@otplib/uri";function u(r,e,t){if(r==="totp")return t.totp();if(r==="hotp"){if(e===void 0)throw new m("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return t.hotp(e)}throw new m(`Unknown OTP strategy: ${r}. Valid strategies are 'totp' or 'hotp'.`)}function O(r){let{strategy:e="totp",issuer:t,label:a,secret:i,algorithm:s="sha1",digits:p=6,period:o=30,counter:n}=r;return u(e,n,{totp:()=>U({issuer:t,label:a,secret:i,algorithm:s,digits:p,period:o}),hotp:g=>B({issuer:t,label:a,secret:i,algorithm:s,digits:p,counter:g})})}async function h(r){let e=l(r),{secret:t,crypto:a,base32:i,algorithm:s,digits:p}=e,o={secret:t,crypto:a,base32:i,algorithm:s,digits:p};return u(e.strategy,e.counter,{totp:()=>H({...o,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>V({...o,counter:n,guardrails:e.guardrails})})}function d(r){let e=l(r),{secret:t,crypto:a,base32:i,algorithm:s,digits:p}=e,o={secret:t,crypto:a,base32:i,algorithm:s,digits:p};return u(e.strategy,e.counter,{totp:()=>v({...o,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>R({...o,counter:n,guardrails:e.guardrails})})}async function T(r){let e=f(r),{secret:t,token:a,crypto:i,base32:s,algorithm:p,digits:o}=e,n={secret:t,token:a,crypto:i,base32:s,algorithm:p,digits:o};return u(e.strategy,e.counter,{totp:()=>C({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:g=>G({...n,counter:g,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function P(r){let e=f(r),{secret:t,token:a,crypto:i,base32:s,algorithm:p,digits:o}=e,n={secret:t,token:a,crypto:i,base32:s,algorithm:p,digits:o};return u(e.strategy,e.counter,{totp:()=>D({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:g=>x({...n,counter:g,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}var b=class{strategy;crypto;base32;guardrails;constructor(e={}){let{strategy:t="totp",crypto:a=c,base32:i=y,guardrails:s}=e;this.strategy=t,this.crypto=a,this.base32=i,this.guardrails=A(s)}getStrategy(){return this.strategy}generateSecret(e=20){return I({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return h({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateSync(e){return d({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}async verify(e){return T({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}verifySync(e){return P({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateURI(e){return O({...e,strategy:this.strategy})}};export{b as OTP};
//# sourceMappingURL=class.js.map