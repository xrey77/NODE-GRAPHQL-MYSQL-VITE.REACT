import{generateSecret as m,ConfigurationError as T}from"@otplib/core";import{generate as d,generateSync as h,verify as P,verifySync as S}from"@otplib/hotp";import{generate as V,generateSync as b,verify as x,verifySync as H}from"@otplib/totp";import{generateTOTP as R,generateHOTP as v}from"@otplib/uri";import{createGuardrails as O}from"@otplib/core";import{base32 as l}from"@otplib/plugin-base32-scure";import{crypto as y}from"@otplib/plugin-crypto-noble";function u(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??y,base32:t.base32??l,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??O()}}function f(t){return{...u(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0}}function g(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new T("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new T(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function I(t){let{crypto:e=y,base32:r=l,length:o=20}=t||{};return m({crypto:e,base32:r,length:o})}function j(t){let{strategy:e="totp",issuer:r,label:o,secret:i,algorithm:s="sha1",digits:p=6,period:n=30,counter:a}=t;return g(e,a,{totp:()=>R({issuer:r,label:o,secret:i,algorithm:s,digits:p,period:n}),hotp:c=>v({issuer:r,label:o,secret:i,algorithm:s,digits:p,counter:c})})}async function A(t){let e=u(t),{secret:r,crypto:o,base32:i,algorithm:s,digits:p}=e,n={secret:r,crypto:o,base32:i,algorithm:s,digits:p};return g(e.strategy,e.counter,{totp:()=>V({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:a=>d({...n,counter:a,guardrails:e.guardrails})})}function E(t){let e=u(t),{secret:r,crypto:o,base32:i,algorithm:s,digits:p}=e,n={secret:r,crypto:o,base32:i,algorithm:s,digits:p};return g(e.strategy,e.counter,{totp:()=>b({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:a=>h({...n,counter:a,guardrails:e.guardrails})})}async function q(t){let e=f(t),{secret:r,token:o,crypto:i,base32:s,algorithm:p,digits:n}=e,a={secret:r,token:o,crypto:i,base32:s,algorithm:p,digits:n};return g(e.strategy,e.counter,{totp:()=>x({...a,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:c=>P({...a,counter:c,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function M(t){let e=f(t),{secret:r,token:o,crypto:i,base32:s,algorithm:p,digits:n}=e,a={secret:r,token:o,crypto:i,base32:s,algorithm:p,digits:n};return g(e.strategy,e.counter,{totp:()=>H({...a,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:c=>S({...a,counter:c,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}export{A as generate,I as generateSecret,E as generateSync,j as generateURI,q as verify,M as verifySync};
//# sourceMappingURL=functional.js.map