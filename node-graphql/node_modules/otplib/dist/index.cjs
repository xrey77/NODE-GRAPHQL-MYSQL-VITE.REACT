"use strict";var G=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var k=Object.prototype.hasOwnProperty;var j=(t,e)=>{for(var r in e)G(t,r,{get:e[r],enumerable:!0})},z=(t,e,r,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of w(e))!k.call(t,a)&&a!==r&&G(t,a,{get:()=>e[a],enumerable:!(i=I(e,a))||i.enumerable});return t};var W=t=>z(G({},"__esModule",{value:!0}),t);var E={};j(E,{HOTP:()=>U.HOTP,NobleCryptoPlugin:()=>A.NobleCryptoPlugin,OTP:()=>R,ScureBase32Plugin:()=>D.ScureBase32Plugin,TOTP:()=>B.TOTP,createGuardrails:()=>u.createGuardrails,generate:()=>d,generateSecret:()=>C,generateSync:()=>b,generateURI:()=>h,stringToBytes:()=>u.stringToBytes,verify:()=>S,verifySync:()=>V,wrapResult:()=>u.wrapResult,wrapResultAsync:()=>u.wrapResultAsync});module.exports=W(E);var f=require("@otplib/core"),y=require("@otplib/hotp"),g=require("@otplib/totp"),P=require("@otplib/uri");var v=require("@otplib/core"),l=require("@otplib/plugin-base32-scure"),c=require("@otplib/plugin-crypto-noble");function T(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??c.crypto,base32:t.base32??l.base32,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??(0,v.createGuardrails)()}}function H(t){return{...T(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0}}function m(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new f.ConfigurationError("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new f.ConfigurationError(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function C(t){let{crypto:e=c.crypto,base32:r=l.base32,length:i=20}=t||{};return(0,f.generateSecret)({crypto:e,base32:r,length:i})}function h(t){let{strategy:e="totp",issuer:r,label:i,secret:a,algorithm:o="sha1",digits:p=6,period:s=30,counter:n}=t;return m(e,n,{totp:()=>(0,P.generateTOTP)({issuer:r,label:i,secret:a,algorithm:o,digits:p,period:s}),hotp:O=>(0,P.generateHOTP)({issuer:r,label:i,secret:a,algorithm:o,digits:p,counter:O})})}async function d(t){let e=T(t),{secret:r,crypto:i,base32:a,algorithm:o,digits:p}=e,s={secret:r,crypto:i,base32:a,algorithm:o,digits:p};return m(e.strategy,e.counter,{totp:()=>(0,g.generate)({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>(0,y.generate)({...s,counter:n,guardrails:e.guardrails})})}function b(t){let e=T(t),{secret:r,crypto:i,base32:a,algorithm:o,digits:p}=e,s={secret:r,crypto:i,base32:a,algorithm:o,digits:p};return m(e.strategy,e.counter,{totp:()=>(0,g.generateSync)({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>(0,y.generateSync)({...s,counter:n,guardrails:e.guardrails})})}async function S(t){let e=H(t),{secret:r,token:i,crypto:a,base32:o,algorithm:p,digits:s}=e,n={secret:r,token:i,crypto:a,base32:o,algorithm:p,digits:s};return m(e.strategy,e.counter,{totp:()=>(0,g.verify)({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:O=>(0,y.verify)({...n,counter:O,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function V(t){let e=H(t),{secret:r,token:i,crypto:a,base32:o,algorithm:p,digits:s}=e,n={secret:r,token:i,crypto:a,base32:o,algorithm:p,digits:s};return m(e.strategy,e.counter,{totp:()=>(0,g.verifySync)({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:O=>(0,y.verifySync)({...n,counter:O,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}var x=require("@otplib/core");var R=class{strategy;crypto;base32;guardrails;constructor(e={}){let{strategy:r="totp",crypto:i=c.crypto,base32:a=l.base32,guardrails:o}=e;this.strategy=r,this.crypto=i,this.base32=a,this.guardrails=(0,x.createGuardrails)(o)}getStrategy(){return this.strategy}generateSecret(e=20){return(0,x.generateSecret)({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return d({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateSync(e){return b({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}async verify(e){return S({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}verifySync(e){return V({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateURI(e){return h({...e,strategy:this.strategy})}};var U=require("@otplib/hotp"),B=require("@otplib/totp"),u=require("@otplib/core"),A=require("@otplib/plugin-crypto-noble"),D=require("@otplib/plugin-base32-scure");0&&(module.exports={HOTP,NobleCryptoPlugin,OTP,ScureBase32Plugin,TOTP,createGuardrails,generate,generateSecret,generateSync,generateURI,stringToBytes,verify,verifySync,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map