{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/parse.ts","../src/generate.ts"],"sourcesContent":["export { parse, parse as parseURI } from \"./parse.js\";\n\nexport { generate, generateTOTP, generateHOTP } from \"./generate.js\";\nexport type { URIOptions, TOTPURIOptions, HOTPURIOptions } from \"./generate.js\";\n\nexport {\n  URIParseError,\n  InvalidURIError,\n  MissingParameterError,\n  InvalidParameterError,\n} from \"./types.js\";\n\nexport type { OTPAuthURI, OTPAuthParams, OTPType } from \"./types.js\";\n","import type { HashAlgorithm, Digits } from \"@otplib/core\";\n\n/**\n * OTP type (HOTP or TOTP)\n */\nexport type OTPType = \"hotp\" | \"totp\";\n\n/**\n * otpauth:// URI parameters\n */\nexport type OTPAuthParams = {\n  /**\n   * Base32-encoded shared secret (required)\n   */\n  readonly secret: string;\n\n  /**\n   * Service/provider name (recommended)\n   */\n  readonly issuer?: string;\n\n  /**\n   * Hash algorithm (default: sha1)\n   * Note: Google Authenticator only supports sha1\n   */\n  readonly algorithm?: HashAlgorithm;\n\n  /**\n   * Number of digits (default: 6)\n   * Google Authenticator supports 6 or 8\n   */\n  readonly digits?: Digits;\n\n  /**\n   * Initial counter value for HOTP (default: 0)\n   */\n  readonly counter?: number;\n\n  /**\n   * Time step in seconds for TOTP (default: 30)\n   */\n  readonly period?: number;\n};\n\n/**\n * otpauth:// URI structure\n */\nexport type OTPAuthURI = {\n  /**\n   * Type of OTP (hotp or totp)\n   */\n  readonly type: OTPType;\n\n  /**\n   * The label (typically: issuer:account or account)\n   */\n  readonly label: string;\n\n  /**\n   * Parameters from the URI\n   */\n  readonly params: OTPAuthParams;\n};\n\n/**\n * Error thrown when URI parsing fails\n */\nexport class URIParseError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"URIParseError\";\n  }\n}\n\n/**\n * Error thrown when URI is invalid\n */\nexport class InvalidURIError extends URIParseError {\n  constructor(uri: string) {\n    super(`Invalid otpauth URI: ${uri}`);\n    this.name = \"InvalidURIError\";\n  }\n}\n\n/**\n * Error thrown when URI has missing required parameters\n */\nexport class MissingParameterError extends URIParseError {\n  constructor(param: string) {\n    super(`Missing required parameter: ${param}`);\n    this.name = \"MissingParameterError\";\n  }\n}\n\n/**\n * Error thrown when URI has invalid parameter value\n */\nexport class InvalidParameterError extends URIParseError {\n  constructor(param: string, value: string) {\n    super(`Invalid value for parameter '${param}': ${value}`);\n    this.name = \"InvalidParameterError\";\n  }\n}\n","import { InvalidURIError, InvalidParameterError } from \"./types.js\";\n\nimport type { OTPAuthURI, OTPAuthParams } from \"./types.js\";\nimport type { HashAlgorithm, Digits } from \"@otplib/core\";\n\n// Security limits to prevent DoS attacks\nconst MAX_URI_LENGTH = 2048; // Standard URL length limit\nconst MAX_LABEL_LENGTH = 512;\nconst MAX_PARAM_VALUE_LENGTH = 1024;\n\n/**\n * Format error message for caught errors\n * @internal\n */\nexport function formatErrorMessage(error: unknown, context: string): string {\n  const errorStr = error instanceof Error ? error.message : String(error);\n  return `Invalid URI encoding in ${context}: ${errorStr}`;\n}\n\n/**\n * Safely decode a URI component with length validation and error handling\n * @throws {InvalidURIError} If decoding fails or length exceeds limit\n */\nfunction safeDecodeURIComponent(str: string, maxLength: number, context: string): string {\n  if (str.length > maxLength * 3) {\n    throw new InvalidURIError(`${context} exceeds maximum length`);\n  }\n\n  try {\n    const decoded = decodeURIComponent(str);\n    if (decoded.length > maxLength) {\n      throw new InvalidURIError(`${context} exceeds maximum length of ${maxLength} characters`);\n    }\n    return decoded;\n  } catch (error) {\n    if (error instanceof InvalidURIError) {\n      throw error;\n    }\n    throw new InvalidURIError(formatErrorMessage(error, context));\n  }\n}\n\n/**\n * Parse an otpauth:// URI into its components\n *\n * @param uri - The otpauth:// URI to parse\n * @returns Parsed URI components\n * @throws {InvalidURIError} If URI is invalid\n * @throws {MissingParameterError} If required parameters are missing\n * @throws {InvalidParameterError} If parameter values are invalid\n *\n * @example\n * ```ts\n * import { parse } from '@otplib/uri';\n *\n * const uri = 'otpauth://totp/ACME:john@example.com?secret=JBSWY3DPEHPK3PXP&issuer=ACME';\n * const parsed = parse(uri);\n * // {\n * //   type: 'totp',\n * //   label: 'ACME:john@example.com',\n * //   params: { secret: 'JBSWY3DPEHPK3PXP', issuer: 'ACME' }\n * // }\n * ```\n */\nexport function parse(uri: string): OTPAuthURI {\n  if (uri.length > MAX_URI_LENGTH) {\n    throw new InvalidURIError(`URI exceeds maximum length of ${MAX_URI_LENGTH} characters`);\n  }\n\n  if (!uri.startsWith(\"otpauth://\")) {\n    throw new InvalidURIError(uri);\n  }\n\n  const withoutScheme = uri.slice(\"otpauth://\".length);\n  const slashIndex = withoutScheme.indexOf(\"/\");\n\n  if (slashIndex === -1) {\n    throw new InvalidURIError(uri);\n  }\n\n  const type = withoutScheme.slice(0, slashIndex);\n  if (type !== \"hotp\" && type !== \"totp\") {\n    throw new InvalidParameterError(\"type\", type);\n  }\n\n  const remaining = withoutScheme.slice(slashIndex + 1);\n  const queryIndex = remaining.indexOf(\"?\");\n\n  let label: string;\n  let queryString: string;\n\n  if (queryIndex === -1) {\n    label = safeDecodeURIComponent(remaining, MAX_LABEL_LENGTH, \"label\");\n    queryString = \"\";\n  } else {\n    label = safeDecodeURIComponent(remaining.slice(0, queryIndex), MAX_LABEL_LENGTH, \"label\");\n    queryString = remaining.slice(queryIndex + 1);\n  }\n\n  const params = parseQueryString(queryString);\n\n  return {\n    type,\n    label,\n    params,\n  };\n}\n\n/**\n * Parse query string into parameters object\n */\nfunction parseQueryString(queryString: string): OTPAuthParams {\n  // Use mutable type during construction\n  const params: {\n    secret?: string;\n    issuer?: string;\n    algorithm?: HashAlgorithm;\n    digits?: Digits;\n    counter?: number;\n    period?: number;\n  } = {};\n\n  if (!queryString) {\n    return params as OTPAuthParams;\n  }\n\n  const pairs = queryString.split(\"&\");\n  for (const pair of pairs) {\n    const equalIndex = pair.indexOf(\"=\");\n    if (equalIndex === -1) {\n      continue;\n    }\n\n    const key = safeDecodeURIComponent(pair.slice(0, equalIndex), 64, \"parameter key\");\n    const value = safeDecodeURIComponent(\n      pair.slice(equalIndex + 1),\n      MAX_PARAM_VALUE_LENGTH,\n      `parameter '${key}'`,\n    );\n\n    switch (key) {\n      case \"secret\":\n        params.secret = value;\n        break;\n      case \"issuer\":\n        params.issuer = value;\n        break;\n      case \"algorithm\":\n        params.algorithm = parseAlgorithm(value);\n        break;\n      case \"digits\":\n        params.digits = parseDigits(value);\n        break;\n      case \"counter\":\n        params.counter = parseInt(value, 10);\n        break;\n      case \"period\":\n        params.period = parseInt(value, 10);\n        break;\n    }\n  }\n\n  return params as OTPAuthParams;\n}\n\n/**\n * Parse algorithm string\n */\nfunction parseAlgorithm(value: string): HashAlgorithm {\n  const normalized = value.toLowerCase();\n  if (normalized === \"sha1\" || normalized === \"sha-1\") {\n    return \"sha1\";\n  }\n  if (normalized === \"sha256\" || normalized === \"sha-256\") {\n    return \"sha256\";\n  }\n  if (normalized === \"sha512\" || normalized === \"sha-512\") {\n    return \"sha512\";\n  }\n  throw new InvalidParameterError(\"algorithm\", value);\n}\n\n/**\n * Parse digits string\n */\nfunction parseDigits(value: string): Digits {\n  const digits = parseInt(value, 10);\n  if (digits === 6 || digits === 7 || digits === 8) {\n    return digits;\n  }\n  throw new InvalidParameterError(\"digits\", value);\n}\n","import type { OTPAuthURI } from \"./types.js\";\nimport type { HashAlgorithm, Digits } from \"@otplib/core\";\n\n/**\n * Base options for URI generation\n */\nexport type URIOptions = {\n  /**\n   * Service/provider name (e.g., 'ACME Co', 'GitHub', 'AWS')\n   */\n  issuer?: string;\n\n  /**\n   * Account identifier (e.g., email, username)\n   */\n  label?: string;\n\n  /**\n   * Base32-encoded secret key\n   */\n  secret: string;\n\n  /**\n   * Hash algorithm (default: 'sha1')\n   * Note: Google Authenticator only supports sha1\n   */\n  algorithm?: HashAlgorithm;\n\n  /**\n   * Number of digits (default: 6)\n   * Google Authenticator supports 6 or 8, RFC also allows 7\n   */\n  digits?: Digits;\n\n  /**\n   * Time step in seconds for TOTP (default: 30)\n   */\n  period?: number;\n\n  /**\n   * Counter value for HOTP\n   */\n  counter?: number;\n};\n\n/**\n * TOTP-specific URI options\n */\nexport type TOTPURIOptions = URIOptions & {\n  period?: number;\n  counter?: never;\n};\n\n/**\n * HOTP-specific URI options\n */\nexport type HOTPURIOptions = URIOptions & {\n  period?: never;\n  counter?: number;\n};\n\n/**\n * Generate an otpauth:// URI\n *\n * @param uri - The URI components\n * @returns The otpauth:// URI string\n *\n * @example\n * ```ts\n * import { generate } from '@otplib/uri';\n * import { encode } from '@otplib/base32';\n *\n * const secret = encode(new Uint8Array([1, 2, 3, 4, 5]));\n *\n * const uri = generate({\n *   type: 'totp',\n *   label: 'ACME:john@example.com',\n *   params: {\n *     secret,\n *     issuer: 'ACME',\n *     algorithm: 'sha1',\n *     digits: 6,\n *   },\n * });\n * // Returns: 'otpauth://totp/ACME:john%40example.com?secret=...'\n * ```\n */\nexport function generate(uri: OTPAuthURI): string {\n  const { type, label, params } = uri;\n\n  // Encode label parts while preserving ':' as the issuer/account separator\n  const encodedLabel = label\n    .split(\":\")\n    .map((part) => encodeURIComponent(part))\n    .join(\":\");\n\n  let result = `otpauth://${type}/${encodedLabel}?`;\n\n  const queryParams: string[] = [];\n\n  if (params.secret) {\n    queryParams.push(`secret=${params.secret}`);\n  }\n\n  if (params.issuer) {\n    queryParams.push(`issuer=${encodeURIComponent(params.issuer)}`);\n  }\n\n  if (params.algorithm && params.algorithm !== \"sha1\") {\n    queryParams.push(`algorithm=${params.algorithm.toUpperCase()}`);\n  }\n\n  if (params.digits && params.digits !== 6) {\n    queryParams.push(`digits=${params.digits}`);\n  }\n\n  if (type === \"hotp\" && params.counter !== undefined) {\n    queryParams.push(`counter=${params.counter}`);\n  }\n\n  if (type === \"totp\" && params.period !== undefined && params.period !== 30) {\n    queryParams.push(`period=${params.period}`);\n  }\n\n  result += queryParams.join(\"&\");\n\n  return result;\n}\n\n/**\n * Generate a TOTP otpauth:// URI with simplified parameters\n *\n * @param options - TOTP URI generation options\n * @returns The otpauth:// URI string\n */\nexport function generateTOTP(options: TOTPURIOptions & { issuer: string; label: string }): string {\n  const { issuer, label: account, secret, algorithm = \"sha1\", digits = 6, period = 30 } = options;\n\n  const fullLabel = issuer ? `${issuer}:${account}` : account;\n\n  return generate({\n    type: \"totp\",\n    label: fullLabel,\n    params: {\n      secret,\n      issuer,\n      algorithm,\n      digits,\n      period,\n    },\n  });\n}\n\n/**\n * Generate a HOTP otpauth:// URI with simplified parameters\n *\n * @param options - HOTP URI generation options\n * @returns The otpauth:// URI string\n */\nexport function generateHOTP(options: HOTPURIOptions & { issuer: string; label: string }): string {\n  const { issuer, label: account, secret, counter = 0, algorithm = \"sha1\", digits = 6 } = options;\n\n  const fullLabel = issuer ? `${issuer}:${account}` : account;\n\n  return generate({\n    type: \"hotp\",\n    label: fullLabel,\n    params: {\n      secret,\n      issuer,\n      algorithm,\n      digits,\n      counter,\n    },\n  });\n}\n"],"mappings":"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","names":["index_exports","__export","InvalidParameterError","InvalidURIError","MissingParameterError","URIParseError","generate","generateHOTP","generateTOTP","parse","__toCommonJS","URIParseError","message","InvalidURIError","uri","MissingParameterError","param","InvalidParameterError","value","MAX_URI_LENGTH","MAX_LABEL_LENGTH","MAX_PARAM_VALUE_LENGTH","formatErrorMessage","error","context","errorStr","safeDecodeURIComponent","str","maxLength","InvalidURIError","decoded","parse","uri","withoutScheme","slashIndex","type","InvalidParameterError","remaining","queryIndex","label","queryString","params","parseQueryString","pairs","pair","equalIndex","key","value","parseAlgorithm","parseDigits","normalized","digits","generate","uri","type","label","params","encodedLabel","part","result","queryParams","generateTOTP","options","issuer","account","secret","algorithm","digits","period","fullLabel","generateHOTP","counter"]}