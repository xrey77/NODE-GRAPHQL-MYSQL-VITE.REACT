import{createGuardrails as T,normalizeSecret as G,normalizeEpochTolerance as j,validateEpochTolerance as z,validatePeriod as g,validateSecret as v,validateTime as d,validateToken as F,requireSecret as V,requireCryptoPlugin as w,AfterTimeStepNegativeError as J,AfterTimeStepNotIntegerError as K,AfterTimeStepRangeExceededError as Q}from"@otplib/core";import{generate as W,generateSync as X}from"@otplib/hotp";import{generateSecret as k,requireCryptoPlugin as y,requireBase32Plugin as h,requireSecret as P,requireLabel as H,requireIssuer as B,requireBase32String as U,createGuardrails as L}from"@otplib/core";import{generateTOTP as N}from"@otplib/uri";var b=class{options;guardrails;constructor(e={}){this.options=e,this.guardrails=L(e.guardrails)}generateSecret(){let{crypto:e,base32:n}=this.options;return y(e),h(n),k({crypto:e,base32:n})}async generate(e){let n={...this.options,...e},{secret:a,crypto:i,base32:o,algorithm:c="sha1",digits:p=6,period:s=30,epoch:u,t0:r=0}=n;P(a),y(i),h(o);let l=e?.guardrails??this.guardrails;return S({secret:a,algorithm:c,digits:p,period:s,epoch:u??Math.floor(Date.now()/1e3),t0:r,crypto:i,base32:o,guardrails:l})}async verify(e,n){let a={...this.options,...n},{secret:i,crypto:o,base32:c,algorithm:p="sha1",digits:s=6,period:u=30,epoch:r,t0:l=0,epochTolerance:f=0,afterTimeStep:m}=a;P(i),y(o),h(c);let O=n?.guardrails??this.guardrails;return C({secret:i,token:e,algorithm:p,digits:s,period:u,epoch:r??Math.floor(Date.now()/1e3),t0:l,epochTolerance:f,afterTimeStep:m,crypto:o,base32:c,guardrails:O})}toURI(e){let{issuer:n,label:a,secret:i,algorithm:o="sha1",digits:c=6,period:p=30}=this.options,s=e?.label??a,u=e?.issuer??n,r=e?.secret??i;return P(r),H(s),B(u),U(r),N({issuer:u,label:s,secret:r,algorithm:o,digits:c,period:p})}};import{wrapResult as pe,wrapResultAsync as le}from"@otplib/core";function R(t){let{secret:e,epoch:n=Math.floor(Date.now()/1e3),t0:a=0,period:i=30,algorithm:o="sha1",digits:c=6,crypto:p,base32:s,guardrails:u=T()}=t;V(e),w(p);let r=G(e,s);v(r,u),d(n),g(i,u);let l=Math.floor((n-a)/i);return{secret:r,counter:l,algorithm:o,digits:c,crypto:p,guardrails:u}}async function S(t){let e=R(t);return W(e)}function Y(t){let e=R(t);return X(e)}function Z(t,e){if(t!==void 0){if(t<0)throw new J;if(!Number.isSafeInteger(t))throw new K;if(t>e)throw new Q}}function M(t,e){return e!==void 0&&t<=e}function I(t){let{secret:e,token:n,epoch:a=Math.floor(Date.now()/1e3),t0:i=0,period:o=30,algorithm:c="sha1",digits:p=6,crypto:s,base32:u,epochTolerance:r=0,afterTimeStep:l,guardrails:f=T()}=t;V(e),w(s);let m=G(e,u);v(m,f),d(a),g(o,f),F(n,p),z(r,o,f);let O=Math.floor((a-i)/o),[q,A]=j(r),D=Math.max(0,Math.floor((a-q-i)/o)),x=Math.floor((a+A-i)/o);return Z(l,x),{token:n,crypto:s,minCounter:D,maxCounter:x,currentCounter:O,t0:i,period:o,afterTimeStep:l,getGenerateOptions:E=>({secret:m,epoch:E*o+i,t0:i,period:o,algorithm:c,digits:p,crypto:s,guardrails:f})}}async function C(t){let{token:e,crypto:n,minCounter:a,maxCounter:i,currentCounter:o,t0:c,period:p,afterTimeStep:s,getGenerateOptions:u}=I(t);for(let r=a;r<=i;r++){if(M(r,s))continue;let l=await S(u(r));if(n.constantTimeEqual(l,e))return{valid:!0,delta:r-o,epoch:r*p+c,timeStep:r}}return{valid:!1}}function oe(t){let{token:e,crypto:n,minCounter:a,maxCounter:i,currentCounter:o,t0:c,period:p,afterTimeStep:s,getGenerateOptions:u}=I(t);for(let r=a;r<=i;r++){if(M(r,s))continue;let l=Y(u(r));if(n.constantTimeEqual(l,e))return{valid:!0,delta:r-o,epoch:r*p+c,timeStep:r}}return{valid:!1}}function ie(t=Math.floor(Date.now()/1e3),e=30,n=0,a=T()){return d(t),g(e,a),(Math.floor((t-n)/e)+1)*e+n-t}function ae(t=Math.floor(Date.now()/1e3),e=30,n=0,a=T()){return d(t),g(e,a),Math.floor((t-n)/e)}export{b as TOTP,S as generate,Y as generateSync,ie as getRemainingTime,ae as getTimeStepUsed,C as verify,oe as verifySync,pe as wrapResult,le as wrapResultAsync};
//# sourceMappingURL=index.js.map