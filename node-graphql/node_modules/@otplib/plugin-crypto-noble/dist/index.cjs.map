{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { hmac } from \"@noble/hashes/hmac.js\";\nimport { sha1 } from \"@noble/hashes/legacy.js\";\nimport { sha256, sha512 } from \"@noble/hashes/sha2.js\";\nimport { randomBytes } from \"@noble/hashes/utils.js\";\nimport { constantTimeEqual as constantTimeEqualUtil } from \"@otplib/core\";\n\nimport type { CryptoPlugin } from \"@otplib/core\";\n\n/**\n * Pure JavaScript implementation of CryptoPlugin\n *\n * This plugin uses @noble/hashes which provides:\n * - Pure JavaScript implementations of hash functions\n * - Zero dependencies and audited code\n * - Cross-platform compatibility (Node.js, browser, edge)\n * - Fallback for environments without native crypto APIs\n *\n * @example\n * ```ts\n * import { NobleCryptoPlugin } from '@otplib/plugin-crypto-noble';\n *\n * const crypto = new NobleCryptoPlugin();\n * const hmac = crypto.hmac('sha1', key, data);\n * const random = crypto.randomBytes(20);\n * ```\n */\nexport class NobleCryptoPlugin implements CryptoPlugin {\n  /**\n   * Plugin name for identification\n   */\n  readonly name = \"noble\";\n\n  /**\n   * Compute HMAC using @noble/hashes\n   *\n   * Synchronous implementation using pure JS.\n   *\n   * @param algorithm - Hash algorithm to use\n   * @param key - Secret key\n   * @param data - Data to authenticate\n   * @returns HMAC digest\n   */\n  hmac(algorithm: \"sha1\" | \"sha256\" | \"sha512\", key: Uint8Array, data: Uint8Array): Uint8Array {\n    const hashFn = algorithm === \"sha1\" ? sha1 : algorithm === \"sha256\" ? sha256 : sha512;\n    return hmac(hashFn, key, data);\n  }\n\n  /**\n   * Generate cryptographically secure random bytes\n   *\n   * Uses @noble/hashes' randomBytes which is backed by:\n   * - Node.js crypto.randomBytes in Node.js\n   * - crypto.getRandomValues in browsers\n   * - A PRNG as fallback\n   *\n   * @param length - Number of bytes to generate\n   * @returns Random bytes\n   */\n  randomBytes(length: number): Uint8Array {\n    return randomBytes(length);\n  }\n\n  /**\n   * Constant-time comparison to prevent timing side-channel attacks\n   *\n   * @noble/hashes doesn't provide a constant-time comparison,\n   * so we Use the core utility implementation.\n   *\n   * @param a - First value to compare\n   * @param b - Second value to compare\n   * @returns true if values are equal, false otherwise\n   */\n  constantTimeEqual(a: string | Uint8Array, b: string | Uint8Array): boolean {\n    return constantTimeEqualUtil(a, b);\n  }\n}\n\n/**\n * Default singleton instance for convenience\n *\n * @example\n * ```ts\n * import { crypto } from '@otplib/plugin-crypto-noble';\n *\n * const hmac = crypto.hmac('sha1', key, data);\n * ```\n */\nexport const crypto: CryptoPlugin = Object.freeze(new NobleCryptoPlugin());\n\nexport default NobleCryptoPlugin;\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,uBAAAE,EAAA,WAAAC,EAAA,YAAAC,IAAA,eAAAC,EAAAL,GAAA,IAAAM,EAAqB,iCACrBC,EAAqB,mCACrBC,EAA+B,iCAC/BC,EAA4B,kCAC5BC,EAA2D,wBAsB9CR,EAAN,KAAgD,CAI5C,KAAO,QAYhB,KAAKS,EAAyCC,EAAiBC,EAA8B,CAE3F,SAAO,QADQF,IAAc,OAAS,OAAOA,IAAc,SAAW,SAAS,SAC3DC,EAAKC,CAAI,CAC/B,CAaA,YAAYC,EAA4B,CACtC,SAAO,eAAYA,CAAM,CAC3B,CAYA,kBAAkBC,EAAwBC,EAAiC,CACzE,SAAO,EAAAC,mBAAsBF,EAAGC,CAAC,CACnC,CACF,EAYab,EAAuB,OAAO,OAAO,IAAID,CAAmB,EAElEE,EAAQF","names":["index_exports","__export","NobleCryptoPlugin","crypto","index_default","__toCommonJS","import_hmac","import_legacy","import_sha2","import_utils","import_core","algorithm","key","data","length","a","b","constantTimeEqualUtil"]}