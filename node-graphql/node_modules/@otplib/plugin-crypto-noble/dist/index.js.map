{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { hmac } from \"@noble/hashes/hmac.js\";\nimport { sha1 } from \"@noble/hashes/legacy.js\";\nimport { sha256, sha512 } from \"@noble/hashes/sha2.js\";\nimport { randomBytes } from \"@noble/hashes/utils.js\";\nimport { constantTimeEqual as constantTimeEqualUtil } from \"@otplib/core\";\n\nimport type { CryptoPlugin } from \"@otplib/core\";\n\n/**\n * Pure JavaScript implementation of CryptoPlugin\n *\n * This plugin uses @noble/hashes which provides:\n * - Pure JavaScript implementations of hash functions\n * - Zero dependencies and audited code\n * - Cross-platform compatibility (Node.js, browser, edge)\n * - Fallback for environments without native crypto APIs\n *\n * @example\n * ```ts\n * import { NobleCryptoPlugin } from '@otplib/plugin-crypto-noble';\n *\n * const crypto = new NobleCryptoPlugin();\n * const hmac = crypto.hmac('sha1', key, data);\n * const random = crypto.randomBytes(20);\n * ```\n */\nexport class NobleCryptoPlugin implements CryptoPlugin {\n  /**\n   * Plugin name for identification\n   */\n  readonly name = \"noble\";\n\n  /**\n   * Compute HMAC using @noble/hashes\n   *\n   * Synchronous implementation using pure JS.\n   *\n   * @param algorithm - Hash algorithm to use\n   * @param key - Secret key\n   * @param data - Data to authenticate\n   * @returns HMAC digest\n   */\n  hmac(algorithm: \"sha1\" | \"sha256\" | \"sha512\", key: Uint8Array, data: Uint8Array): Uint8Array {\n    const hashFn = algorithm === \"sha1\" ? sha1 : algorithm === \"sha256\" ? sha256 : sha512;\n    return hmac(hashFn, key, data);\n  }\n\n  /**\n   * Generate cryptographically secure random bytes\n   *\n   * Uses @noble/hashes' randomBytes which is backed by:\n   * - Node.js crypto.randomBytes in Node.js\n   * - crypto.getRandomValues in browsers\n   * - A PRNG as fallback\n   *\n   * @param length - Number of bytes to generate\n   * @returns Random bytes\n   */\n  randomBytes(length: number): Uint8Array {\n    return randomBytes(length);\n  }\n\n  /**\n   * Constant-time comparison to prevent timing side-channel attacks\n   *\n   * @noble/hashes doesn't provide a constant-time comparison,\n   * so we Use the core utility implementation.\n   *\n   * @param a - First value to compare\n   * @param b - Second value to compare\n   * @returns true if values are equal, false otherwise\n   */\n  constantTimeEqual(a: string | Uint8Array, b: string | Uint8Array): boolean {\n    return constantTimeEqualUtil(a, b);\n  }\n}\n\n/**\n * Default singleton instance for convenience\n *\n * @example\n * ```ts\n * import { crypto } from '@otplib/plugin-crypto-noble';\n *\n * const hmac = crypto.hmac('sha1', key, data);\n * ```\n */\nexport const crypto: CryptoPlugin = Object.freeze(new NobleCryptoPlugin());\n\nexport default NobleCryptoPlugin;\n"],"mappings":"AAAA,OAAS,QAAAA,MAAY,wBACrB,OAAS,QAAAC,MAAY,0BACrB,OAAS,UAAAC,EAAQ,UAAAC,MAAc,wBAC/B,OAAS,eAAAC,MAAmB,yBAC5B,OAAS,qBAAqBC,MAA6B,eAsBpD,IAAMC,EAAN,KAAgD,CAI5C,KAAO,QAYhB,KAAKC,EAAyCC,EAAiBC,EAA8B,CAE3F,OAAOT,EADQO,IAAc,OAASN,EAAOM,IAAc,SAAWL,EAASC,EAC3DK,EAAKC,CAAI,CAC/B,CAaA,YAAYC,EAA4B,CACtC,OAAON,EAAYM,CAAM,CAC3B,CAYA,kBAAkBC,EAAwBC,EAAiC,CACzE,OAAOP,EAAsBM,EAAGC,CAAC,CACnC,CACF,EAYaC,EAAuB,OAAO,OAAO,IAAIP,CAAmB,EAElEQ,EAAQR","names":["hmac","sha1","sha256","sha512","randomBytes","constantTimeEqualUtil","NobleCryptoPlugin","algorithm","key","data","length","a","b","crypto","index_default"]}