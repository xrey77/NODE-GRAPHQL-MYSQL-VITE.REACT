import{counterToBytes as D,createCryptoContext as U,createGuardrails as j,dynamicTruncate as h,truncateDigits as H,validateCounter as b,validateSecret as C,validateToken as z,validateCounterTolerance as E,normalizeSecret as x,normalizeCounterTolerance as M,requireSecret as G,requireCryptoPlugin as V}from"@otplib/core";import{generateSecret as S,requireCryptoPlugin as y,requireBase32Plugin as g,requireSecret as m,requireLabel as q,requireIssuer as I,requireBase32String as A,createGuardrails as N}from"@otplib/core";import{generateHOTP as w}from"@otplib/uri";var O=class{options;guardrails;constructor(e={}){this.options=e,this.guardrails=N(e.guardrails)}generateSecret(){let{crypto:e,base32:t}=this.options;return y(e),g(t),S({crypto:e,base32:t})}async generate(e,t){let r={...this.options,...t},{secret:n,crypto:o,base32:s,algorithm:a="sha1",digits:i=6}=r;m(n),y(o),g(s);let c=t?.guardrails??this.guardrails;return f({secret:n,counter:e,algorithm:a,digits:i,crypto:o,base32:s,guardrails:c})}async verify(e,t){let r={...this.options,...t},{secret:n,crypto:o,base32:s,algorithm:a="sha1",digits:i=6,counterTolerance:c=0}=r;m(n),y(o),g(s);let p=t?.guardrails??this.guardrails;return T({secret:n,token:e.token,counter:e.counter,algorithm:a,digits:i,counterTolerance:c,crypto:o,base32:s,guardrails:p})}toURI(e=0){let{issuer:t,label:r,secret:n,algorithm:o="sha1",digits:s=6}=this.options;return m(n),q(r),I(t),A(n),w({issuer:t,label:r,secret:n,algorithm:o,digits:s,counter:e})}};import{wrapResult as $,wrapResultAsync as tt}from"@otplib/core";function v(u){let{secret:e,counter:t,algorithm:r="sha1",digits:n=6,crypto:o,base32:s,guardrails:a}=u;G(e),V(o);let i=x(e,s);C(i,a),b(t,a);let c=U(o),p=D(t);return{ctx:c,algorithm:r,digits:n,secretBytes:i,counterBytes:p}}async function f(u){let{ctx:e,algorithm:t,digits:r,secretBytes:n,counterBytes:o}=v(u),s=await e.hmac(t,n,o),a=h(s);return H(a,r)}function L(u){let{ctx:e,algorithm:t,digits:r,secretBytes:n,counterBytes:o}=v(u),s=e.hmacSync(t,n,o),a=h(s);return H(a,r)}function R(u){let{secret:e,counter:t,token:r,algorithm:n="sha1",digits:o=6,crypto:s,base32:a,counterTolerance:i=0,guardrails:c=j()}=u;G(e),V(s);let p=x(e,a);C(p,c),b(t,c),z(r,o),E(i,c);let l=typeof t=="bigint"?Number(t):t,[d,P]=M(i),k=d+P+1;return{token:r,counterNum:l,past:d,future:P,totalChecks:k,crypto:s,getGenerateOptions:B=>({secret:p,counter:B,algorithm:n,digits:o,crypto:s,guardrails:c})}}async function T(u){let{token:e,counterNum:t,past:r,totalChecks:n,crypto:o,getGenerateOptions:s}=R(u),a=Math.max(0,r-t);for(let i=a;i<n;i++){let c=i-r,p=t+c,l=await f(s(p));if(o.constantTimeEqual(l,e))return{valid:!0,delta:c|0}}return{valid:!1}}function X(u){let{token:e,counterNum:t,past:r,totalChecks:n,crypto:o,getGenerateOptions:s}=R(u),a=Math.max(0,r-t);for(let i=a;i<n;i++){let c=i-r,p=t+c,l=L(s(p));if(o.constantTimeEqual(l,e))return{valid:!0,delta:c|0}}return{valid:!1}}export{O as HOTP,f as generate,L as generateSync,T as verify,X as verifySync,$ as wrapResult,tt as wrapResultAsync};
//# sourceMappingURL=index.js.map