"use strict";var d=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var R=Object.getOwnPropertyNames;var k=Object.prototype.hasOwnProperty;var B=(c,t)=>{for(var e in t)d(c,e,{get:t[e],enumerable:!0})},S=(c,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of R(t))!k.call(c,n)&&n!==e&&d(c,n,{get:()=>t[n],enumerable:!(o=v(t,n))||o.enumerable});return c};var q=c=>S(d({},"__esModule",{value:!0}),c);var A={};B(A,{HOTP:()=>m,generate:()=>O,generateSync:()=>C,verify:()=>P,verifySync:()=>I,wrapResult:()=>f.wrapResult,wrapResultAsync:()=>f.wrapResultAsync});module.exports=q(A);var r=require("@otplib/core");var s=require("@otplib/core"),H=require("@otplib/uri");var m=class{options;guardrails;constructor(t={}){this.options=t,this.guardrails=(0,s.createGuardrails)(t.guardrails)}generateSecret(){let{crypto:t,base32:e}=this.options;return(0,s.requireCryptoPlugin)(t),(0,s.requireBase32Plugin)(e),(0,s.generateSecret)({crypto:t,base32:e})}async generate(t,e){let o={...this.options,...e},{secret:n,crypto:i,base32:a,algorithm:p="sha1",digits:u=6}=o;(0,s.requireSecret)(n),(0,s.requireCryptoPlugin)(i),(0,s.requireBase32Plugin)(a);let l=e?.guardrails??this.guardrails;return O({secret:n,counter:t,algorithm:p,digits:u,crypto:i,base32:a,guardrails:l})}async verify(t,e){let o={...this.options,...e},{secret:n,crypto:i,base32:a,algorithm:p="sha1",digits:u=6,counterTolerance:l=0}=o;(0,s.requireSecret)(n),(0,s.requireCryptoPlugin)(i),(0,s.requireBase32Plugin)(a);let y=e?.guardrails??this.guardrails;return P({secret:n,token:t.token,counter:t.counter,algorithm:p,digits:u,counterTolerance:l,crypto:i,base32:a,guardrails:y})}toURI(t=0){let{issuer:e,label:o,secret:n,algorithm:i="sha1",digits:a=6}=this.options;return(0,s.requireSecret)(n),(0,s.requireLabel)(o),(0,s.requireIssuer)(e),(0,s.requireBase32String)(n),(0,H.generateHOTP)({issuer:e,label:o,secret:n,algorithm:i,digits:a,counter:t})}};var f=require("@otplib/core");function b(c){let{secret:t,counter:e,algorithm:o="sha1",digits:n=6,crypto:i,base32:a,guardrails:p}=c;(0,r.requireSecret)(t),(0,r.requireCryptoPlugin)(i);let u=(0,r.normalizeSecret)(t,a);(0,r.validateSecret)(u,p),(0,r.validateCounter)(e,p);let l=(0,r.createCryptoContext)(i),y=(0,r.counterToBytes)(e);return{ctx:l,algorithm:o,digits:n,secretBytes:u,counterBytes:y}}async function O(c){let{ctx:t,algorithm:e,digits:o,secretBytes:n,counterBytes:i}=b(c),a=await t.hmac(e,n,i),p=(0,r.dynamicTruncate)(a);return(0,r.truncateDigits)(p,o)}function C(c){let{ctx:t,algorithm:e,digits:o,secretBytes:n,counterBytes:i}=b(c),a=t.hmacSync(e,n,i),p=(0,r.dynamicTruncate)(a);return(0,r.truncateDigits)(p,o)}function x(c){let{secret:t,counter:e,token:o,algorithm:n="sha1",digits:i=6,crypto:a,base32:p,counterTolerance:u=0,guardrails:l=(0,r.createGuardrails)()}=c;(0,r.requireSecret)(t),(0,r.requireCryptoPlugin)(a);let y=(0,r.normalizeSecret)(t,p);(0,r.validateSecret)(y,l),(0,r.validateCounter)(e,l),(0,r.validateToken)(o,i),(0,r.validateCounterTolerance)(u,l);let g=typeof e=="bigint"?Number(e):e,[T,h]=(0,r.normalizeCounterTolerance)(u),G=T+h+1;return{token:o,counterNum:g,past:T,future:h,totalChecks:G,crypto:a,getGenerateOptions:V=>({secret:y,counter:V,algorithm:n,digits:i,crypto:a,guardrails:l})}}async function P(c){let{token:t,counterNum:e,past:o,totalChecks:n,crypto:i,getGenerateOptions:a}=x(c),p=Math.max(0,o-e);for(let u=p;u<n;u++){let l=u-o,y=e+l,g=await O(a(y));if(i.constantTimeEqual(g,t))return{valid:!0,delta:l|0}}return{valid:!1}}function I(c){let{token:t,counterNum:e,past:o,totalChecks:n,crypto:i,getGenerateOptions:a}=x(c),p=Math.max(0,o-e);for(let u=p;u<n;u++){let l=u-o,y=e+l,g=C(a(y));if(i.constantTimeEqual(g,t))return{valid:!0,delta:l|0}}return{valid:!1}}0&&(module.exports={HOTP,generate,generateSync,verify,verifySync,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map