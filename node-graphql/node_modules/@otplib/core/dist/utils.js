var s=class extends Error{constructor(e,t){super(e,t),this.name="OTPError"}},c=class extends s{constructor(e){super(e),this.name="SecretError"}},p=class extends c{constructor(e,t){super(`Secret must be at least ${e} bytes (${e*8} bits), got ${t} bytes`),this.name="SecretTooShortError"}},l=class extends c{constructor(e,t){super(`Secret must not exceed ${e} bytes, got ${t} bytes`),this.name="SecretTooLongError"}},x=class extends s{constructor(e){super(e),this.name="CounterError"}},d=class extends x{constructor(){super("Counter must be non-negative"),this.name="CounterNegativeError"}},m=class extends x{constructor(){super("Counter exceeds maximum safe integer value"),this.name="CounterOverflowError"}},D=class extends s{constructor(e){super(e),this.name="TimeError"}},g=class extends D{constructor(){super("Time must be non-negative"),this.name="TimeNegativeError"}},T=class extends s{constructor(e){super(e),this.name="PeriodError"}},E=class extends T{constructor(e){super(`Period must be at least ${e} second(s)`),this.name="PeriodTooSmallError"}},f=class extends T{constructor(e){super(`Period must not exceed ${e} seconds`),this.name="PeriodTooLargeError"}};var b=class extends s{constructor(e){super(e),this.name="TokenError"}},h=class extends b{constructor(e,t){super(`Token must be ${e} digits, got ${t}`),this.name="TokenLengthError"}},O=class extends b{constructor(){super("Token must contain only digits"),this.name="TokenFormatError"}};var A=class extends s{constructor(e){super(e),this.name="CounterToleranceError"}},y=class extends A{constructor(e,t){super(`Counter tolerance validation failed: total checks (${t}) exceeds MAX_WINDOW (${e})`),this.name="CounterToleranceTooLargeError"}},P=class extends A{constructor(){super("Counter tolerance cannot contain negative values"),this.name="CounterToleranceNegativeError"}},w=class extends s{constructor(e){super(e),this.name="EpochToleranceError"}},S=class extends w{constructor(){super("Epoch tolerance cannot contain negative values"),this.name="EpochToleranceNegativeError"}},_=class extends w{constructor(e,t){super(`Epoch tolerance must not exceed ${e} seconds, got ${t}. Large tolerances can cause performance issues.`),this.name="EpochToleranceTooLargeError"}},R=class extends s{constructor(e){super(e),this.name="PluginError"}},I=class extends R{constructor(){super("Crypto plugin is required."),this.name="CryptoPluginMissingError"}},M=class extends R{constructor(){super("Base32 plugin is required."),this.name="Base32PluginMissingError"}},u=class extends s{constructor(e){super(e),this.name="ConfigurationError"}},v=class extends u{constructor(){super("Secret is required. Use generateSecret() to create one, or provide via { secret: 'YOUR_BASE32_SECRET' }"),this.name="SecretMissingError"}},C=class extends u{constructor(){super("Label is required for URI generation. Example: { label: 'user@example.com' }"),this.name="LabelMissingError"}},B=class extends u{constructor(){super("Issuer is required for URI generation. Example: { issuer: 'MyApp' }"),this.name="IssuerMissingError"}},U=class extends u{constructor(){super("Class API requires secret to be a Base32 string, not Uint8Array. Use generateSecret() or provide a Base32-encoded string."),this.name="SecretTypeError"}};var k=new TextEncoder,W=new TextDecoder,Y=16,z=64,F=20,V=1,j=3600,H=30,J=Number.MAX_SAFE_INTEGER,K=99,N=Symbol("otplib.guardrails.override"),a=Object.freeze({MIN_SECRET_BYTES:Y,MAX_SECRET_BYTES:z,MIN_PERIOD:V,MAX_PERIOD:j,MAX_COUNTER:J,MAX_WINDOW:K,[N]:!1});function sr(r){return r?Object.freeze({...a,...r,[N]:!0}):a}function or(r){return r[N]??!1}function ir(r,e=a){if(r.length<e.MIN_SECRET_BYTES)throw new p(e.MIN_SECRET_BYTES,r.length);if(r.length>e.MAX_SECRET_BYTES)throw new l(e.MAX_SECRET_BYTES,r.length)}function ar(r,e=a){let t=typeof r=="bigint"?r:BigInt(r);if(t<0n)throw new d;if(t>BigInt(e.MAX_COUNTER))throw new m}function ur(r){if(r<0)throw new g}function cr(r,e=a){if(!Number.isInteger(r)||r<e.MIN_PERIOD)throw new E(e.MIN_PERIOD);if(r>e.MAX_PERIOD)throw new f(e.MAX_PERIOD)}function pr(r,e){if(r.length!==e)throw new h(e,r.length);if(!/^\d+$/.test(r))throw new O}function lr(r,e=a){let[t,n]=Z(r);if(t<0||n<0)throw new P;let o=t+n+1;if(o>e.MAX_WINDOW)throw new y(e.MAX_WINDOW,o)}function xr(r,e=H,t=a){let[n,o]=Array.isArray(r)?r:[r,r];if(n<0||o<0)throw new S;let i=t.MAX_WINDOW*e,X=Math.max(n,o);if(X>i)throw new _(i,X)}function dr(r){let e=typeof r=="bigint"?r:BigInt(r),t=new ArrayBuffer(8);return new DataView(t).setBigUint64(0,e,!1),new Uint8Array(t)}function mr(r){let e=r[r.length-1]&15;return(r[e]&127)<<24|r[e+1]<<16|r[e+2]<<8|r[e+3]}function gr(r,e){let t=10**e;return(r%t).toString().padStart(e,"0")}function Q(r,e){return r.length===e.length}function Tr(r,e){let t=$(r),n=$(e);if(!Q(t,n))return!1;let o=0;for(let i=0;i<t.length;i++)o|=t[i]^n[i];return o===0}function Er(r){switch(r){case"sha1":return 20;case"sha256":return 32;case"sha512":return 64}}function $(r){return typeof r=="string"?k.encode(r):r}function fr(r){return W.decode(r)}function br(r,e){return typeof r=="string"?(G(e),e.decode(r)):r}function hr(r){let{crypto:e,base32:t,length:n=F}=r;rr(e),G(t);let o=e.randomBytes(n);return t.encode(o,{padding:!1})}function Z(r=0){return Array.isArray(r)?r:[0,r]}function Or(r=0){return Array.isArray(r)?r:[r,r]}function rr(r){if(!r)throw new I}function G(r){if(!r)throw new M}function Ar(r){if(!r)throw new v}function yr(r){if(!r)throw new C}function Pr(r){if(!r)throw new B}function wr(r){if(typeof r!="string")throw new U}function L(r){return{ok:!0,value:r}}function q(r){return{ok:!1,error:r}}function Sr(r){return(...e)=>{try{return L(r(...e))}catch(t){return q(t)}}}function _r(r){return async(...e)=>{try{return L(await r(...e))}catch(t){return q(t)}}}export{H as DEFAULT_PERIOD,J as MAX_COUNTER,j as MAX_PERIOD,z as MAX_SECRET_BYTES,K as MAX_WINDOW,V as MIN_PERIOD,Y as MIN_SECRET_BYTES,F as RECOMMENDED_SECRET_BYTES,fr as bytesToString,Tr as constantTimeEqual,dr as counterToBytes,sr as createGuardrails,mr as dynamicTruncate,hr as generateSecret,Er as getDigestSize,or as hasGuardrailOverrides,Z as normalizeCounterTolerance,Or as normalizeEpochTolerance,br as normalizeSecret,G as requireBase32Plugin,wr as requireBase32String,rr as requireCryptoPlugin,Pr as requireIssuer,yr as requireLabel,Ar as requireSecret,$ as stringToBytes,gr as truncateDigits,Q as validateByteLengthEqual,ar as validateCounter,lr as validateCounterTolerance,xr as validateEpochTolerance,cr as validatePeriod,ir as validateSecret,ur as validateTime,pr as validateToken,Sr as wrapResult,_r as wrapResultAsync};
//# sourceMappingURL=utils.js.map