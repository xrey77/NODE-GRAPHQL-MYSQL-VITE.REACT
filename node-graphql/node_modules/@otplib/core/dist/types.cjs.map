{"version":3,"sources":["../src/types.ts"],"sourcesContent":["/**\n * Supported hash algorithms for HMAC operations\n */\nexport type HashAlgorithm = \"sha1\" | \"sha256\" | \"sha512\";\n\n/**\n * Supported number of digits for OTP codes\n */\nexport type Digits = 6 | 7 | 8;\n\n/**\n * Cryptographic plugin type for abstracting HMAC and random byte generation\n * across different runtime environments (Node.js, browser, edge, etc.)\n */\nexport type CryptoPlugin = {\n  /**\n   * The name of the crypto plugin (e.g., 'node', 'web', 'js')\n   */\n  readonly name: string;\n\n  /**\n   * Compute HMAC using the specified hash algorithm\n   *\n   * @param algorithm - The hash algorithm to use\n   * @param key - The secret key as a byte array\n   * @param data - The data to authenticate as a byte array\n   * @returns HMAC digest as a byte array\n   */\n  hmac(\n    algorithm: HashAlgorithm,\n    key: Uint8Array,\n    data: Uint8Array,\n  ): Promise<Uint8Array> | Uint8Array;\n\n  /**\n   * Generate cryptographically secure random bytes\n   *\n   * @param length - Number of random bytes to generate\n   * @returns Random bytes\n   */\n  randomBytes(length: number): Uint8Array;\n\n  /**\n   * Constant-time comparison to prevent timing side-channel attacks\n   *\n   * Compares two values in a way that takes constant time regardless of\n   * whether they match or differ. This prevents timing attacks where an\n   * attacker could determine the secret by measuring comparison time.\n   *\n   * @param a - First value to compare (string or Uint8Array)\n   * @param b - Second value to compare (string or Uint8Array)\n   * @returns true if values are equal, false otherwise\n   */\n  constantTimeEqual(a: string | Uint8Array, b: string | Uint8Array): boolean;\n};\n\n/**\n * Base32 encoding/decoding options\n */\nexport type Base32EncodeOptions = {\n  /**\n   * Whether to include padding characters (=)\n   * Default: false (Google Authenticator compatible)\n   * Note: RFC 4648 specifies padding should be included\n   */\n  padding?: boolean;\n};\n\n/**\n * Base32 plugin type for abstracting Base32 encoding/decoding\n * across different implementations (native, TypeScript, etc.)\n */\nexport type Base32Plugin = {\n  /**\n   * The name of the base32 plugin (e.g., 'native', 'ts')\n   */\n  readonly name: string;\n\n  /**\n   * Encode binary data to Base32 string\n   *\n   * @param data - Uint8Array to encode\n   * @param options - Encoding options\n   * @returns Base32 encoded string\n   */\n  encode(data: Uint8Array, options?: Base32EncodeOptions): string;\n\n  /**\n   * Decode Base32 string to binary data\n   *\n   * @param str - Base32 string to decode\n   * @returns Decoded Uint8Array\n   * @throws {Error} If string contains invalid characters\n   */\n  decode(str: string): Uint8Array;\n};\n\n/**\n * Base options for secret generation\n */\nexport type SecretOptions = {\n  /**\n   * Crypto plugin for random byte generation\n   */\n  readonly crypto: CryptoPlugin;\n\n  /**\n   * Base32 plugin for encoding\n   */\n  readonly base32: Base32Plugin;\n\n  /**\n   * Number of random bytes to generate (default: 20)\n   * 20 bytes = 160 bits, which provides a good security margin\n   */\n  readonly length?: number;\n};\n\n// ============================================================================\n// Result Type for Functional Error Handling\n// ============================================================================\n\n/**\n * Success result containing a value\n */\nexport type OTPResultOk<T> = {\n  readonly ok: true;\n  readonly value: T;\n};\n\n/**\n * Failure result containing an error\n */\nexport type OTPResultError<E> = {\n  readonly ok: false;\n  readonly error: E;\n};\n\n/**\n * Result type for functional error handling\n *\n * Allows returning errors as values instead of throwing exceptions.\n * Use with `generateSafe()` and `verifySafe()` functions.\n *\n * @example\n * ```typescript\n * const result = await generateSafe({ secret, crypto, base32 });\n * if (result.ok) {\n *   console.log('Token:', result.value);\n * } else {\n *   console.log('Error:', result.error.message);\n * }\n * ```\n */\nexport type OTPResult<T, E = Error> = OTPResultOk<T> | OTPResultError<E>;\n"],"mappings":"+WAAA,IAAAA,EAAA,kBAAAC,EAAAD","names":["types_exports","__toCommonJS"]}